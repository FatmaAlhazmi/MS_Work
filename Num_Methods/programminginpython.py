# -*- coding: utf-8 -*-
"""ProgrammingInPython.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qhML2ajO3WaJSkm5Bz-otlhcBbhVhVns

# Numerical Methods
# Introduction to Programming in Python

PSI Start Online School 2023

Lauren Hayward

This notebook introduces how to use Jupyter notebooks, basics of Pythons, and some libraries and packages that will be useful throughout the course. You will find a total of 8 exercises (with solutions) in the sections below.

## 1. Basics of Jupyter notebooks

You can run Python code using either a notebook (like this one) or a script.
A script is executed from top to bottom, whereas a notebook is divided into cells.
Here we use a notebook because its interactive environment and rich narrative text capabilities make it ideal for teaching and tutorial purposes.

In Jupyter notebooks, you type input into cells and execute a cell using `Shift+Enter`. In Google Colaboratory, you can also run Code cells using the play button.

## 2. Basics of Python

### 2.1. Numbers

We can use Python as a calculator for evaluating numerical expressions.
Available arithmetic operators are:

| Operator  | Description    |
| :-------- |:-------------- |
| `+`       | addition |
| `-`       | subtraction |
| `*`       | multiplication |
| `/`       | division or floor division (see below) |
| `//`      | floor division (also known as integer division) |
| `**`      | exponent (**Note:** the operator `^` is not an exponential operator!) |
| `%`       | modulus (returns the remainder upon dividing the left-hand operand by the right-hand operand) |
"""

(1+3)*(6-4)**3

9%5

3/2

"""Numbers can have different numeric types.
Integer numbers (such as `2`, `-9` and `0`) have type `int`.
Numbers with a decimal (such as `13.4`, `4.0` and `-12.2`) have type `float`.
You can also read about long integers and complex numbers, but we won't use them in this course.
Python can determine the number's type without being explicitly told.

Booleans (variables that take one of two possible values) are a subtype of integers.

In Python 2, the output of the operation `a/b` depends on the types of the operands `a` and `b`.
If `a` and `b` are both of type `int`, then `a/b` will perform integer division and return an integer.
If at least one of `a` or `b` is of type `float`, then `a/b` performs division and returns a floating-point number.

In Python 3, the operation `a/b` always performs division.
Integer division is performed by writing `a//b`.
"""

7/3

7.0/3

7.0//3

"""### 2.2. Printing

If we enter several numerical expressions on different lines of the same cell, only the last line will be displayed.
"""

2+4
6-5

"""Use the `print(x)` function to display the value of the expression `x`.
In Python 2, use `print` without an argument to print an empty line.
In Python 3, use `print()` to print an empty line.
"""

print(2+4)
print()
print(6-5)

"""### 2.3. Variables and comments

Store values in a variable using the equal sign.

Use comments to document your code. Any text following a `#` character on a line will not be interpreted by Python and will thus not affect the code's output.
"""

w = 10 #width of rectangle
h = 4  #height of rectangle
print( w*h ) #print the area

"""### 2.4. Strings

In addition to numbers, you can store and manipulate strings of characters.
You can use either single or double quotes to define a string.
"""

word1 = "Hello"
word2 = "world"
sentence = word1 + " " + word2 #concatenate strings using '+'
print( sentence )

L = len( sentence ) #get the length
print( L )

"""Use the format method to get formatted strings, which are often useful for displaying output in a nice way"""

subject = "Numerical Methods"
start_date = "May 25"
end_date = "June 15"
num_lectures=7
print( "The {} course within the PSI Start online school will run from {} to {} and will consist of {} lectures.".format(subject,start_date,end_date,num_lectures) )

"""**Exercise #1:** Write code that takes a variable storing a circle's radius and prints its area. For example, when `r=5`, you should print:

`The area of the circle is 78.53975.`
"""

### SOLUTION ###
r  = 5
pi = 3.14159
area = pi*r**2
print( "The area of the circle is {}.".format(area) )

"""### 2.5. Lists

Python has several data types available for grouping data together.
The first one that we will see is the `list`.
To define a list, use square brackets with comma-separated values.
The elements of a list can be of the same type or of different types.
Lists can even contain other lists.

Some useful functions and methods for `lists` are:

| `list` function/method  | Description    |
| :---------------------- |:-------------- |
| `+`                     | concatenates `lists` |
| `len(list)`             | outputs the `list` length  |
| `min(list)`             | outputs the smallest item in `list`  |
| `max(list)`             | outputs the largest item in `list`  |
| `list.append(x)`        | adds a new item `x` to the end of `list`  |
| `list.sort()`           | sorts the elements of `list`  |
| `sorted(list)`          | return a new sorted list with the elements of `list`  |
"""

A = [4,12,-2]
B = ["a", 0, 4.2, [4,5] ]
print( "A = {},   B = {}".format(A,B) )
print

print( "A+B = {}".format(A+B) )
print( "max(A) = {}".format(max(A)) )
print( "len(B) = {}".format(len(B)) )

A.append(3)
print( "\nAfter appending 3:  A = {}".format(A) )

A.append(B)
print( "After appending B:  A = {}".format(A) )

#Compare sort vs. sorted:
C = [6,-2.45,12.3,-203]
print( "Initially,          C = {}".format(C) )

D = sorted(C)
print( "After using sorted, C = {},  D = {}".format(C,D) )

C.sort()
print( "After using sort,   C = {}".format(C) )

"""### 2.6. Indexing and slicing

Both strings and lists can be indexed. The first element always has index 0.

You can also use negative indices to index elements counting from end.
"""

B = ["a", 0, 4.2, [4,5] ]
print( B[0] )  #prints the first element
print( B[-1] ) #prints the last element
print( B[-4] ) #prints the fourth-last element (the first element in this case)
print( B[3][1] ) #prints the second element of the fourth element

"""Use *slicing* to get a subset of your list or string."""

s = "abcdef"
print( s[1:4] ) #print the characters from index 1 to 4 (1 is included and 4 is excluded)
print( s[4:]  ) #the last index defaults to the length of the string/list
print( s[:3]  ) #the first index defaults to 0

#Use an optional third slicing argument to denote the step size:
print( s[1:4:2]) #consider at every second character

"""**Exercise #2:** Given the list below, use slicing to display its elements in reverse order"""

A = ['a','b','c','d','e','f']

### SOLUTION ###
A = ['a','b','c','d','e','f']
print( A[::-1] )

"""An important difference between lists and string is that lists ar *mutable* (can be changed), while string are *immutable* (cannot be changed).

The `del` statement can be used to delete items from a list.
"""

B = ["a", 0, 4.2, [4,5] ]
B[0] = "b" #changes the first element
print( B )
del B[1:3]
print( B )

s = "abcdef"
s[0] = 'b' #generates an error

"""**Exercise #3:** Given the string `s` below, use indexing and/or slicing to generate a new string `ss` that is the same as `s` but with the first letter changed to `b`."""

s = "abcdef"

### SOLUTION ###
s = "abcdef"
ss = 'b' + s[1:]
print( ss )

"""### 2.7. Dictionaries

Dictionaries are another mutable data type in Python.
Unlike a `list`, which is indexed by a range of numbers, a `dict` is indexed by keys that you define.
Each key can be a string, a number, or any other immutable type.
You can think of a dictionary as a mapping.
"""

D = {"abc":"a", "a":0, 4:2}
print( D )
print( D["a"] )
print( D.keys() ) #use 'keys' to get all of the dictionary keys

D["new key"] = 13 #add a new item to the dictionary
print( D )

"""You can read about other available data structures such as tuples and sets, but we won't use them in this course.

### 2.8. Other useful Python tools

#### `type`

Use the `type` function to output a value's type.
"""

type(4.2)

A = [3,4,5]
type(A)

A = [3,4,5]
type(A[0])

"""####  `range`

The `range` function can be used to generate lists that contain sequences of numbers.
"""

#With one argument, range(stop) gives a sequence of integers from 0 to stop-1:
print( list(range(12)) )

#With two arguments, range(start,stop) gives a sequence of integers from start to stop-1
print( list(range(2,12)) )

#An optional third argument is the step size:
print( list(range(2,12,5)) )

"""#### `import` and `time`

Often, we will want to use a package or module that is not included by default.
In this case we can use the `import` command to import packages, functions, modules or submodules.

One such useful module is called `time` and can be used for timing how long code takes to run.
"""

import time #import the time module

t1 = time.time() #get the time at the beginning (in seconds)

A = [4,2,8]
B = [1,2,3]
C = A+B

t2 = time.time() #get the time at the end (in seconds)

print("Elapsed time: {} seconds".format(t2-t1) )

"""## 3. Control structures

### 3.1. `if` statement

An `if` statement is used if we want to execute some section of code only if some conditional expression is true.

For example, the code segment

`if x:
    print("Hello")
`
    
will print `Hello` only if the *truth value* of `x` is true.

The truth value of `x` is false if it is has the value `None`, `False`, zero (of any numeric type), or if it is empty (or example, if it is an empty list, string or dictionary).
Otherwise, the truth value of `x` is true.
"""

if 13.4:
    print("Hello")

if 0:
    print("Hello")

if [0]:
    print("Hello")

"""Examples of conditional expressions are:

| Conditional expressions  | Description    |
| :----------------------  |:-------------- |
| `a or b`                 | logical OR  |
| `a and b`                | logical AND |
| `not a`                  | logical NOT |
| `a < b`                  | less than |
| `a <= b`                 | less than or equal to |
| `a > b`                  | greater than |
| `a >= b`                 | greater than or equal to |
| `a == b`                 | equal |

The `if` statement can be combined with one or more optional `elif` (else-if) statements and one optional `else` statement.
"""

a=5
b=15.6
c=0

if a+b < 10:
    c=b
    print( "Hi" )
elif a != 2:
    c=a
    print( "Hello" )
elif b>a:
    print( "Hey" )
else:
    print( "Bye" )

print("c={}".format(c))

"""**Note:** The `if` statement is the first place where we can see how whitespace is interpreted in Python.
In other languages, blocks often start and end with curly braces (`{` and `}`) or with keywords (such as `begin` and `end`).
In these languages, the blocks are often indented for readability but this whitespace is not actually meaningful (the code gives the same result if these indents are removed).
In Python, however, indents are necessary within the blocks.

### 3.2. `for` loop

A `for` loop can be used to iterate over the items of a sequence.
"""

A = ['b',10,8.25]

for i in A:
    print(i)

for num in range(8,14):
    print( num )

"""### 3.3. Some useful functions to use with `for` loops

#### `zip`

You can use `zip` to iterate over the elements of several parallel lists.
"""

room_names = ["Alice", "Bob", "Space", "Time"]
floor_nums = [3, 4, 4, 2]

for r, f in zip(room_names, floor_nums):
    print( "The {} Room is on floor #{} at Perimeter Institute".format(r,f) )

"""#### `enumerate`

You can use `enumerate` to iterate while also keeping track of the iteration index.
"""

events = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]

for i,e in enumerate(events):
    print( "Weekday #{} is {}".format(i,e) )

"""### 3.4. `while` loop

In addition to a `for` loop, a `while` loop can be used to repeat sections of code.
The `while` loop

`while x:
    [while block]
`

will repeatedly execute the while body as long as the condition `x` is true.
"""

a = 10

while a>0:
    print(a)
    a = a-2

"""### 3.5. Defining functions

Use the keyword `def` to define your own function.
This function can then be called from other parts of your code.
Optionally, your function can accept one or more input parameters.
As another option, you can use a `return` statement to return one or more values from your function.
"""

#Function with no input parameters:
def printHello():
    print("Hello there!")

printHello()

#Function with two input parameters:
def get_c(a,b):
    c = 5*a - b
    print(c)

get_c(1,2)
get_c(4.3,-2)

#Function with one input parameter and two return values:
def getElements(x):
    return x[0], x[3]

a,b = getElements([6,9,10,15,16])
print("a = {}, b = {}".format(a,b))

"""### 3.6. List comprehension

List comprehension can be used to build lists in a concise way.
A list is built using at least one `for` clause as well as optional `if` clauses.
"""

L1 = [i for i in range(10)]
print( L1 )

A = [7,-8,2,20]
B = [a*2 for a in A if a>0]
print( B )

"""**Exercise #4:** Given the list `A` below, use list comprehension to get a new list `B` containing the squares of the even elements of `A`."""

A = [8,62,11,12,33,65]

### SOLUTION ###
A = [8,62,11,12,33,65]
B = [i**2 for i in A if i%2==0]
print(B)

"""We can also study list comprehension examples with two `for` clauses:"""

A = [3,4]
B = [4,7,11]
C = [a+b for a in A for b in B if a!=b]
print(C)

"""List comprehension can be much faster than appending to a list."""

t1 = time.time()

#Append to a list:
L = []
for i in range(10**7):
    L.append(i)

t2 = time.time() #get the time at the end (in seconds)

print("Elapsed time: {} seconds".format(t2-t1) )

t1 = time.time()

#Use list comprehension:
L = [i for i in range(10**7)]

t2 = time.time() #get the time at the end (in seconds)

print("Elapsed time: {} seconds".format(t2-t1) )

"""## 4. The NumPy package

Here we will explore some of the scientific computing functionality available through the NumPy package.

Whenever we want to use NumPy, we must first import it.
A standard convention is to import it under the name `np`.
"""

import numpy as np

"""### 4.1. Arrays

The most common objects in NumPy are single- or multi-dimensional arrays.
Arrays are tables of values that all have the same type.
Here we will only consider arrays of numbers.

There are various functions available for creating NumPy arrays.
"""

#Create arrays from other data structures such as lists:

A = np.array([5, -2, 12]) #Create a 1D array
print( A )
print

B = np.array( [ [0.4, 3.4, -2.5], [12.0, 6.4, 8.2] ] ) #Create a 2D array
print( B )

#Use np.zeros to create arrays of zeros of different sizes and dimensions.
#Similarly, use np.ones to create arrays of ones.
print( np.zeros(3) )
print
print( np.ones((6,5)) )
print
print( np.zeros((3,2,2)) )

#Use np.arange to create arrays containing sequences of numbers (similar to range for lists)
print( np.arange(8) )
print
print( np.arange(-10,10,5) )

#Use np.linspace get an array of linearly spaced numbers between given endpoints
print( np.linspace(2,10,20) ) #20 points between 2 and 10

"""The functions `size`, `shape` and `ndims` are available for determining an array's size and dimensionality."""

A = np.array( [[4,4,2], [3,8,10]] )
print( A.size ) #total number of elements
print( A.shape ) #size along each dimension
print( A.ndim ) #number of dimensions

"""### 4.2. Basic array operations

#### Arithmetic operators

Arithmetic operators are applied elementwise for arrays.
"""

A_list = [4,5,6]
A_arr = np.array(A_list)

B_list = [10,11,12]
B_arr = np.array(B_list)

print( A_list + B_list ) #The + concatenates lists
print( A_arr + B_arr )   #The + is elementwise addition for arrays

A = np.array([3.2, 4.8, 1.1])
B = np.array([1.2, 10.3, 9.9])

print( A - 1 ) #elementwise subtraction
print( A * B ) #elementwise multiplication
print( B / A ) #elementwise division
print( B**2 )  #elementwise exponential

"""**Exercise #5:** Define a function that will take as input two NumPy arrays of the same size and outputs the elementwise sum of their squared elements. Discuss your solution with another student. Can you find a way to make your code more efficient?"""

### SOLUTION ###
import numpy as np

def sum_squares(x,y):
    return x**2 + y**2

A = np.array([6,4,8])
B = np.array([5.4,-0.2,0])
S = sum_squares(A,B)
print(S)

"""#### Mathematical functions

Numpy has several built-in mathematical functions that act elementwise on arrays `x`, such as:

| NumPy function  | Description    |
| :-------------------------  |:-------------- |
| `np.sqrt(x)`                | elementwise square-root  |
| `np.exp(x)`                 | elementwise exponential  |
| `np.log(x)`                 | elementwise natural logarithm  |
| `np.abs(x)`                 | elementwise absolute value  |
| `np.sin(x)`                 | elementwise sine  |
| `np.cos(x)`                 | elementwise cosine  |
| `np.tan(x)`                 | elementwise tangent  |
| `np.arcsin(x)`                 | elementwise inverse sine  |
| `np.arccos(x)`                 | elementwise inverse cosine  |
| `np.arctan(x)`                 | elementwise inverse tangent  |
"""

x = np.array([0.2, 1.2, 0.56, 2.1])

print( np.sqrt(x) )
print( np.tan(x) )

"""Some other useful mathematical functions for mathematics and statistics are:

| NumPy function      | Description    |
| :-----------------  |:-------------- |
| `np.sum(x)`         | sum of all elements of `x`  |
| `np.sum(x,axis=a)`  | sum of all elements of `x` over axis `a`  |
| `np.cumsum(x)`         | cumulative sum of the elements of `x`  |
| `np.cumsum(x,axis=a)`  | cumulative sum of the elements of `x` over axis `a`  |
| `np.mean(x)`        | arithmetic mean of all elements of `x`  |
| `np.mean(x,axis=a)` | arithmetic mean of `x` along axis `a`  |
| `np.std(x)`         | arithmetic mean of all elements of `x`  |
| `np.all(x)` | checks whether all elements of `x` are `True`  |
"""

x = np.array( [[3,5,6], [9,2,-3] ] )

print(np.sum(x))
print(np.sum(x,axis=0))
print(np.sum(x,axis=1))
print()

print(np.mean(x,axis=0))
print(np.std(x))
print()

"""### 4.3. Constants

The NumPy package includes several mathematical constants
"""

import numpy as np
print( np.pi ) #pi
print( np.e  ) #base of natural logarithm

"""### 4.4. Random numbers

NumPy offers several functions for generating random numbers and arrays of random numbers.
"""

#Use rand to generate random samples from the uniform distribution over [0,1)
print( np.random.rand() ) #generates one sample
print()
print( np.random.rand(5) ) #generates a 1D array of five samples
print()
print( np.random.rand(4,2) ) #generates a 2D array of eight samples

#Similarly, use randn to generate random samples normal distribution with mean 0 and variance 1
print( np.random.randn(6) )

#To generate random integers, use randint
print( np.random.randint(0,11) ) #generate one random integer in the range [0,10]
print()
print( np.random.randint(6,9,size=10) ) #generates 10 random integers in the range [6,8]

"""**Exercise #6:** Use `np.random.rand` to generate an array of 10 numbers sampled from the uniform distribution [-1,3)"""

### SOLUTION ###
import numpy as np
print( 4*np.random.rand(10) - 1 )

"""### 4.5. Linear algebra"""

A = np.array( [[3,8], [-2,14]] )
A

#Transpose:
A.T

#Inverse:
np.linalg.inv( A )

#Trace:
np.trace( A )

#Eigenvalues and right eigenvectors:
E = np.linalg.eig(A)
print(E)
print()

evals = E[0]
evecs = E[1]
print( evals )
print()
print( evecs )

#2D Identity matrix:
np.eye(4)

#Matrix multiplication:
B = np.random.rand(2,2)
print(B)
print
print( np.matmul(A,B) )
print
print( np.matmul(B,A) )

"""**Exercise #7:** Write code to check if the matrix product of a matrix `A` with its inverse gives the identity matrix. You should print `True` if the product is equal to the identity and `False` otherwise."""

### SOLUTION ###
A = np.array( [[3,8], [-2,14]] )
prod = np.matmul( A, np.linalg.inv( A ) )
print(prod)
print()

print( np.all(prod == np.eye(2)) ) #Gives FALSE since the product is not exactly equal to the identity matrix

#Confirm that we get the identity within some small epsilon (approximate floating point precision):
eps = 1e-15
print( np.all( np.abs( prod - np.eye(2) ) < eps ) )

#Using the np.allclose function:
print( np.allclose(prod, np.eye(2),atol=1e-15) )

"""## 5. Data visualization using Matplotlib

Matplotlib is an extensive plotting library in Python, which offers many versatile functions for generating plots for publications and presentations.
"""

import matplotlib.pyplot as plt
import numpy as np

"""### 5.1. `plt.plot`

Use `plt.plot` to plot two-dimensional data with lines and/or markers.
"""

x = np.linspace(0,3,20)
y1 = x**2
y2 = np.sin(x)

#Very simple plotting script:
plt.plot(x, y1) #plot y1 vs. x
plt.plot(x, y2) #plot y2 vs. x

plt.show() #display the plot

"""Plotting code can be as simple as the lines above, or we can add or modify many features.

The function `plt.plot` takes many optional arguments, such as:

| `plt.plot` argument        | Description    |
| :--------------------------|:-------------- |
| `linestyle` or `ls`        | Style of the line (examples: `'-'`, `'--'`, `'-.'`, `':'`, `'None'`) |
| `linewidth` or `lw`        | A number specifying the width of the line |
| `marker`                   | Style of markers for the data points (examples: `'o'`, `'.'`, `'v'`, `'^'`, `'>'`, `'<'`, `'s'`, `'D'`) |
| `markersize` or `ms`       | A number specifying the size of the markers |
| `markeredgewidth` or `mew` | A number specifying the size of the edge around the markers |
| `label`                    | String to label the data (can use LaTeX) |
| `color` or `c`             | Colour of the line and points (examples: `'b'`, `'g'`, `'r'`, `'c'`, `'m'`, `'y'`, `'k'`, `'w'`, RGB tuple, hex RGB string) |
    | `markeredgecolor` or `mec` | Colour of the edge around the points (has the same possible values as `color`) |
    
There are also several options for adjusting other features of the plot, such as:

| Function                      | Description     |
| :---------------------------- | :-------------- |
| `plt.xlabel` and `plt.ylabel` | Label the $x$ and $y$ axes |
| `plt.xlim` and `plt.ylim`     | Control the limits of the $x$ and $y$ axes |
| `plt.xticks` and `plt.yticks` | Control the tick locations and labels |
| `plt.xscale` and `plt.yscale` | Control whether the $x$ and $y$ axes are `'linear'`, `'log'`, etc. |
| `plt.title`                   | Add a title to the plot |
| `plt.legend`                  | Add a legend to the plot based on the `label` arguments |
"""

#Plot the same data but customize more of the features:
plt.plot(x, y1, ls='-.', lw=4, label="quadratic", color=(0.1,0.8,0.6))
plt.plot(x, y2, ls='None', marker='s', ms = 8, mec='k', mew=2, label=r'$\sin(x)$', color='#F39E1E')

plt.xlabel('time $t$', fontsize=16)
plt.ylabel('$g(t)$', fontsize=22)
plt.xlim([0,1.9])
plt.ylim([-1,4])
plt.xticks([0,0.5,1.0,1.5], fontsize=16)
plt.yticks([0.5,1.7,3.8], ["a", "b", "c"], fontsize=18)
plt.legend(loc='upper left', fontsize=14, frameon=False) #Add a legend and adjust its properties

plt.show() #display the plot

"""### 5.2. `plt.scatter`

Use `plt.scatter` to make two-dimensional scatter plots, where the markers can have varying size and/or color.
This function takes many of the same optional arguments as `plt.plot`.

In addition, an optional argument `c` can specify the colour(s), and an optional argument `s` can specify the marker size(s).
"""

#Simple scatter plot:
N = 70

x = np.linspace(0,4,N)
y = x + 3*np.random.randn(N)

plt.scatter(x, y)
plt.show()

#Scatter plot with varying sizes and colours:
N = 70

x = np.linspace(0,4,N)
y = x + 3*np.random.randn(N)
colours = np.random.rand(N)
sizes = 120*np.abs(np.random.randn(N))

#cmap denotes the name of the colormap (how numbers are mapped to colours)
#examples of cmap names: 'viridis', 'plasma', 'inferno', 'magma', 'cool', 'rainbow', 'jet'
plt.scatter(x, y, c=colours, s=sizes, cmap = 'viridis')
plt.show()

"""### 5.3. `plt.errorbar`

Use `plt.errorbar` to plot two-dimensional data with errorbars.
This function takes many of the same optional arguments as `plt.plot`.

Other optional arguments include:

| `plt.plot` argument        | Description    |
| :--------------------------|:-------------- |
| `xerr` and `yerr`          | Parameters to store the value(s) of the error along $x$ and $y$ |
| `elinewidth`               | A number specifying the width of the errorbars |
| `capsize`                  | A number specifying the length of the errorbar caps |
| `capthick`                 | A number specifying the thickness of the errorbar caps |
"""

N = 8

x  = np.arange(N)
y  = np.sin(x) + 0.4*np.random.rand(N)
dy = 0.25*np.abs( np.random.randn(N) )
dx = 0.45*np.abs( np.random.randn(N) )

plt.errorbar( x, y, xerr=dx, yerr=dy, marker='o', ms=8, ls='-', lw=1, elinewidth=3, capsize=10, capthick=2  )
plt.show()

"""### 5.4. `plt.hist`

Use `plt.hist` to plot histograms.
This function takes many of the same optional arguments as `plt.plot`.

The argument `bin` can be either a integer or a sequence of numbers.
When it is a number `n`, then `n+1` bin edges are used to generate the histogram.
When this argument is a sequence (such as a list), then the values of this sequence specify the bin edges.
"""

x = np.random.randn(100000)

plt.hist(x,100)
plt.show()

"""## 6. The SciPy library

SciPy provides many tools for scientific computing such as

* special functions
* integration
* optimization
* interpolation
* Fourier transforms
* linear algebra
* statistics

We won't explore all of these tools in detail, but let's look at some simple curve fitting for now.

### 6.1. Curve fitting

We will focus here on using the function `scipy.optimize.curve_fit`.
The arguments are the fitting function `f` as well as the data points specified in terms of `xdata` and `ydata`.
The function performs a least squares fit and outputs `popt` (the optimized values for the parameters of `f`) and `pcov` (a estimate for the covariance of `popt`).
"""

import numpy as np
import scipy.optimize

def f1(x,a):
    return a*np.log(x+1)

N=50
x_points = np.arange(N)
y_points = np.log( x_points + 1 ) + 0.7*np.random.randn(N)

#Fit the data to f1:
popt, pcov = scipy.optimize.curve_fit(f1, x_points, y_points)
print(popt)
y_fit1 = f1(x_points,*popt) #use the '*' to "unpack" the elements of popt

plt.plot(x_points, y_points, marker='o', ls='None', label='Data')
plt.plot(x_points, y_fit1, ls='-', label='f1')
plt.legend(loc='upper left')
plt.show()

"""**Exercise #8:** Modify the code in the cell above so that it additionally fits the data to the function ``a*x**b``, where `a` and `b` are both fitting parameters."""

### SOLUTION ###

import matplotlib.pyplot as plt
import numpy as np
import scipy.optimize

def f1(x,a):
    return a*np.log(x+1)

def f2(x,a,b):
    return a*x**b

N=50
x_points = np.arange(N)
y_points = np.log( x_points + 1 ) + 0.7*np.random.randn(N)

#Fit the data to f1:
popt, pcov = scipy.optimize.curve_fit(f1, x_points, y_points)
print(popt)
y_fit1 = f1(x_points,*popt) #use the '*' to "unpack" the elements of popt

#Fit the data to f2:
popt, pcov = scipy.optimize.curve_fit(f2, x_points, y_points)
print(popt)
y_fit2 = f2(x_points,*popt)

plt.plot(x_points, y_points, marker='o', ls='None', label='Data')
plt.plot(x_points, y_fit1, ls='-', label='f1')
plt.plot(x_points, y_fit2, ls='-', label='f2')
plt.legend(loc='upper left')
plt.show()